# Class vs Object

## Introduction

A class is a data type.  An object is a variable.  The terms are often used
interchangable but they are different. To truly understand this there are
two parts of a computer program that need to be addressed first.
The compiler or interrupter and how a program is stored in a computer.
This lesson intends to cover compilers and memory before addressing the
difference between class and object.

## Compilers and Interpreter

Before a program can be run, it must first be compiled and turned into
machine code.  An Interpreter is basically a compiler that runs at the
same time as the program and compiles the program as it runs.  One of the
jobs of a compiler is to determine which parts of the source code are
executable statements, which one define data types, and which ones are
variables.

The primary difference between a compiler and an interpreter is the output.
The compiler output is a file that can be executed by itself over and over
again.  An interpreter output is a program that executes within the
interpreter and only runs once.  Each time a script is to be executed,
it must be run through the interpreter again and again.

Compiled programs run faster than interpreted programs, up to a 1000 times
faster.  So why not use just compiled programs written in languages like
Java, C++, and FORTRAN.   Scripted programs have the advantage that it is
faster to change a script and see if it runs than a compiled language.
Also, with small programs or scripts, the difference of execution time
may be too short to notice the difference.

A Java compiler is a bit different than a compiler for other languages such as
C++.  A Java compiler does not turn the source code into machince code that
can run on the native hardware.  Instead, the Java compiler turns the source
code into something called **pcode**.  This is because Java does not run
directly on the computer hardware.  It runs in a virtual machine where
pcode is its equivalent to machine code.  This is for the Java feature of
_write once --> run everywhere_.  The Java virtual machine, also known as the
**JVM**, is ported to each type of computer system and the JVM translate the
pcode into the local machine code.


## Memory

An executable program, one that has already been compiled, is stored in memory.
Normally, it is stored in a disk file in a shorten form.  The shorten form
will only include the static parts of the program, the machine code, static
data such as strings and constants, along with data that the program will use
during execution that can be determined and set by the compiler.

Each unit of memory has an address used to locate it.  In most computers, a
unit of memory is a byte which is itself comprised of 8 bits1.  There are some
computers that use a word as its unit of memory.  A word is comprised of a
number of bytes.  In the old days, the size of a word could vary from computer
to computer.  The size of a word is usually based on the number of data lines
the computer data bus had for transporting data.  Older PCs had a 16 bit data
bus and its word size was 2 bytes.  Today, the standards are 32 bit and 64 bit
data buses where the word size can range from 4 bytes to 8 bytes.

There have been other computers that use unique word sizes.  The Harris
H-Series had a word size of 24 bits or 3 bytes2.  A CDC series computer had
a word size of 60 bits or 10 6 bit bytes3.  The CDC computers were used before
32 bit data buses were common.

### Program Layout


When a compiled program is about to be executed, it is first copied from disk
into memory.  More memory will be assigned to the program than was needed to
store it in a disk file.  That extra memory is used for dynamic objects and
call stacks.  The compiled program, also called the executable, references
memory starting at zero.  When it is placed in memory, its first memory
address will be a random value that is not zero.  To get around this problem,
an executable will be assigned virtual memory.  Virtual memory is stored in
real memory with the addresses in virtual memory starting at zero.  The program
address its virtual memory space and the operating system will translate
virtual memory addresses into real memory addresses.

Looking at Figure 1, to the right, the first set of addresses store the
machine code of the program.  This is referred to as the Code Segment.
The next two sections contain data, both initialized and uninitialized.
The order of these two data segments can be reversed or even mixed.  These
segments contain the data that does not change size: constants, strings,
predefined global variables.

### Program Execution Memory

![Program Memory](@data/content/images/Executable-Virtual-Memory.png "Program Memory")

The rest of the virtual memory is used to store dynamic data and call stacks.
This is data that is created while the program is running.  This segment is
divided into three parts: the Heap at one end, the Stack at the other end, and
free or unused memory in the middle.

The Stack is used to store variables and objects used that are not created
using the new keyword.  It also stores the call stack whenever execution jumps
to a function or method.  The call stack contains the return value from the
method, the parameters passed to the method, and other information needed by
the computer to jump to the correct machine code and return when the method is
done.   All variables declared in the scope of the meyhod are also pushed onto
the stack.  When execution leaves a scope, all the variables declared in that
scope are popped off the Stack. When the function exits, the return value is
placed in the call stack.  All remaining variables used by the function are
popped off the Stack.  The caller of the function can then access the return
value before it too can be popped off the stack.

The Heap is used to used to store dynamically created variables and objects.
In Java, any object created with the new keyword is a dynamic variable.  Memory
from the Heap is allocated starting with the beginning of the Heap.  If there
are no free or unused chunk of memory within the Heap that is large enough to
contain the variable, the Heap will grow and allocate memory that was from the
free space.

The Stack is a memory where all the memory is used.  In other words, there are
no chunks of unused memory in the Stack.  The Stack grows, increases in size,
as needed and it shrinks, decreases in size, as data is no longer used.  The
Heap, on the other hand, cannot grow and shrink like the Stack because dynamic
variables can still exist when the function that created them returns.  As
dynamic variables are released, the memory used to store them is marked as
available.  This results in holes in the Heap where dynamic memory has been
released and no new dynamic variables have been created that will fit in the
available space.

There is a potential problem with using this Stack/Heap model.  Each program
is allocated a fixed amount of memory to use for the Stack and Heap.  If this
memory runs out, in other words, the Stack meets the Heap, the program will
crash.  The actual size allocated for the Stack and Heap can be changed though
not when the program is executing.  Sometimes, the Stack/Heap space can be
defined as a command line parameter when the program is run.  Sometimes, it
can be specified when compiling the program, and at other times, with changes
to the operating system configuration.  Regardless of how Stack/Heap space can
be changed, if your program does not have enough, it will crash and lose all
the data that is still in memory.


## Classes

Java is know as a Typed Language.  This means that data types are defined,
some by the language and others by the programmer that are know as User Types.

### Primitive Types

In Java, everything is derived from the class Object.  There are some types
that are not really objects because they are considered primitive.  Examples
would be byte, short, int, long, char, boolean, float, and double.  There are
primitive classes used to contain primitive variables.  Some examples of them
are PrimitiveType, NumericType, IntegerType, and FloatingPointType.

### Non-Primitive Types

Beyond the primitives, there are lots of other types defined by Java and its
extensive library.  A prime example would String.  A String holds an array of
char and may encapsulate the length of the array or the number of characters
actually in the array.

### Class Types

In Java source code, the programmer can define their own types.  These are
called user-defined data type or UDT and also just User Type.  All user
defined data types are classes.  Not all classes are defined using the class
keyword.  The enum keyword is used to build special kinds of classes that
define a finite set of named values.  We will ignore enumeration types for
another paper since all that applies to classes applies to enumerations as well.

A class defines a data structure that contains zero or more data members and
zero or more methods.  A class definition in the code is instructions to the
compiler on how to build and use the data structure.  When the compiler
encounters a variable of a class, the compiler generates code that does the
following:

- Allocate memory to hold the object either from the Stack or the Heap.
  - In the case of constants and global variables, the memory will come from
    the initialized or uninitialized data segment.
* Call the constructors for each data member to initialize them1.
- Calls the class constructor to complete the initialization2.
- Returns a reference that is the virtual address of the object.
